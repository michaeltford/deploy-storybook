const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./DPCvyj5K9rQVitWC-h3HmKjk5.js","./preload-helper-PPVm8Dsz.js"])))=>i.map(i=>d[i]);
import{_ as ee}from"./preload-helper-PPVm8Dsz.js";import{M as F}from"./index-CmvF348R.js";import{t as se}from"./index-CvKDCtrJ.js";import"./index-BiBgeh3u.js";import"./iframe-mGP4b_Fh.js";import"./index-DTwpo8e8.js";import"./index-CXJVXQGg.js";import"./client-BMu68Vok.js";/**
 * @license @sheetxl/scripting - Scripting - Scripting engine for Macros and formulas; includes TypeScript and EsBuild. - v0.7.26
 *
 * (C) 2025-present SheetXL Inc. & Michael T. Ford
 * License: The license can be found at https://www.sheetxl.com/license.
 */let L=null,j=null;const ce={compilerOptions:{target:"esnext"}};async function ue(g,w,S="/script.js",b="__SHEETXL"){try{const $=await(async function(){if(L)return L;if(j){if(await j,!L)throw new Error("ESBuild initialization promise resolved, but instance is not available.");return L}let p,T;j=new Promise((a,m)=>{p=a,T=m});try{const{initialize:a}=await ee(async()=>{const{initialize:m}=await import("./DHtoG6tI2hwnhrwX-B-BIg0Oa.js");return{initialize:m}},[],import.meta.url);return L=await a(),p(),L}catch(a){throw console.error("Failed to import or initialize esbuild:",a),j=null,T(a),a}})(),I="@sheetxl/primitives",n=`
      export const FormulaContext = globalThis.${b}?.FormulaContext;
      export const ScalarType = globalThis.${b}?.ScalarType;
      export const Observable = globalThis.${b}?.Observable;
      export const IRange = globalThis.${b}?.IRange;
      export const FormulaError = globalThis.${b}?.FormulaError;
      // Add more exports as needed
    `,z={name:"sheetxl-esbuild-in-memory",setup(p){const T="sheetxl-"+new Date().getTime();p.onResolve({filter:new RegExp(`^(${S.replace("/","\\/")}|${I})$`)},a=>({path:a.path,namespace:T})),p.onResolve({filter:/.*/},a=>{if(a.namespace!==T)return console.warn(`esbuild: Treating import "${a.path}" as external.`),{path:a.path,external:!0}}),p.onLoad({filter:/.*/,namespace:T},a=>{let m;if(a.path===S)m=w;else{if(a.path!==I)return{errors:[{text:`Cannot load unknown path in ${T}: ${a.path}`}]};m=n}return{contents:m,loader:"ts"}})}},h=await $.build({entryPoints:[S],bundle:!0,write:!1,format:"esm",plugins:[z],sourcemap:"inline",tsconfigRaw:ce,minify:!0,platform:"neutral"});if(h.outputFiles&&h.outputFiles.length>0)return h.outputFiles[0].text;throw h.errors&&h.errors.length>0?new Error(`esbuild bundling failed: ${h.errors.map(p=>p.text).join(`
`)}`):new Error("esbuild did not produce an output file.")}catch($){throw console.error("esbuild bundling process failed:",$),$}}const de=async()=>`
  interface FirstTest {
    isTrue?: boolean;
  }
`,te=new Map([["IReferenceRange","r"],["IRange","l"]]),ne=new Map([["IWorkbook","workbook"],["ISheet","sheet"],["ICellRanges","ranges"],["ICellRange","range"],["IFormulaContext","context"]]),U=(g,w)=>{Array.from(w.keys()).forEach(S=>{const b=w.get(S);w.set(`${g}.${S}`,b)})},pe=new Map([["Scalar","*"],["FormulaError.Known",F.Error],["Date","Date"],["JSON","JSON"]]),me=new Map([]),X="SheetXL";U(X,te),U(X,ne),U(X,me);const fe=new Map([["Promise",()=>({async:!0})],["Observable",()=>({stream:!0})]]);let B=null;async function ye(){if(B)return B;try{return await(await ee(async()=>{const{initialize:g}=await import("./DPCvyj5K9rQVitWC-h3HmKjk5.js");return{initialize:g}},__vite__mapDeps([0,1]),import.meta.url)).initialize()}catch(g){throw B=null,g}finally{B=null}}async function Ee(g){const w=g?.source??null;if(!w)return null;const S=(g.disableBundle||g.declarationsOnly)??!1,b=[de(),ye()],$=await Promise.all(b),I=$[0],n=$[1];let z="",h=null;const p=[],T={allowJs:!0,declaration:!1,sourceMap:!1,inlineSourceMap:!1,inlineSources:!1,isolatedModules:!0,preserveConstEnums:!1,module:99,noResolve:!0,emitDeclarationOnly:!1,target:n.ScriptTarget.ES2020},a="script",m=`${a}.ts`,H="lib.d.ts",W="global.d.ts",R={[m]:w,[H]:`
/**
 * Represents the completion of an asynchronous operation
 */
interface Promise<T> {
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
`,[W]:I},re={getSourceFile:(e,t,d,f)=>n.createSourceFile(e,R[e],n.ScriptTarget.Latest,!0),fileExists:e=>R[e]!==void 0,readFile:e=>R[e],writeFile:(e,t)=>{R[e]=t},getCurrentDirectory:()=>"./",getCanonicalFileName:e=>e,useCaseSensitiveFileNames:()=>!0,getDefaultLibFileName:e=>H,getNewLine:()=>`
`},J=n.createProgram([m,W],T,re),P=J.getTypeChecker(),ie=J.getSourceFile(m),G=J.emit();G.diagnostics.length>0&&console.warn(G.diagnostics),z=R[`${a}.js`];const O=(e,t,d,f)=>{if(e){if(e.kind===n.SyntaxKind.NumberKeyword)t.scalar=F.Number;else if(e.kind===n.SyntaxKind.StringKeyword)t.scalar=F.String;else if(e.kind===n.SyntaxKind.BooleanKeyword)t.scalar=F.Boolean;else if(e.kind===n.SyntaxKind.UndefinedKeyword||e.kind===n.SyntaxKind.NullKeyword||e.kind===n.SyntaxKind.VoidKeyword){if(f)return void k(e,new Error(`'undefined' is not a valid type for input: '${e?.parent?.name?.escapedText}'.`));t.scalar=F.Null}else if(e.kind===n.SyntaxKind.BigIntKeyword)t.scalar=F.Number;else if(e.kind===n.SyntaxKind.AnyKeyword)t.scalar=F.Null;else if(e.kind===n.SyntaxKind.ArrayType){const o=e.elementType;if(!o)return void k(e,new Error(`'Array' must be typed: '${e?.parent?.name?.escapedText}'.`));t.arrayDepth=(t.arrayDepth??0)+1,O(o,t,d,f)}else if(e.kind!==n.SyntaxKind.TupleType&&e.kind===n.SyntaxKind.TypeReference){const o=e.typeName?.getText?.()??null,M=te.get(o);let E=!1;M&&(t.range=M,E=!0);const C=pe.get(o);if(C&&(t.scalar=C),C!==void 0&&(E=!0),f){const r=ne.get(o);if(r)return r}else{const r=fe.get(o);if(r){const l={...t,...r()};let x=0;if(l.async&&x++,l.stream&&x++,x>1)return void k(e,new Error(`'${o}' cannot have multiple modifiers: '${e?.parent?.name?.escapedText}'.`));t=l,E=!0}}if(!E)return void k("node",new Error(`'${o}' is not a valid type: '${e?.parent?.name?.escapedText}'.`));const c=e.typeArguments;if(c){if(c.length!==1)return void k(e,new Error(`'${o}' must be typed with exactly 1 type: '${e?.parent?.name?.escapedText}'.`));O(c[0],t,d,f)}}}else k(e,new Error(`Type is not defined for '${t?.name??"return"}'.`))},D=[],k=(e,t)=>{D.push(t)};if(n.forEachChild(ie,e=>{if((t=>(n.getCombinedModifierFlags(t)&n.ModifierFlags.Export)!==0)(e)&&n.isFunctionDeclaration(e)){const t={},d={parameters:{}},f=e?.name?.getText();try{t.name=f;const o=P.getSymbolAtLocation(e.name).getDocumentationComment(P);if(o&&o.length>0&&o[0].text){let c=o[0].text;c=c.replace(/[\r\n]+/g,"\\n").trim(),d.summary=c}const M={};O(e.type,M,t,!1),t.returnType=M;const E={};(c=>(n.getCombinedModifierFlags(c)&n.ModifierFlags.Default)!==0)(e)&&(E.default=!0,h=f),Object.keys(E).length>0&&(t.behavior=E),t.parameters=[];const C=new Map;for(let c=0;c<e.parameters.length;c++){const r=e.parameters[c],l={};l.name=r.name?.getText();const x=O(r.type,l,t,!0);if(x){if(t.parameters.length!==0){const s=e?.parent,i=s?.name?.getText();return void k(e,new Error(`'${t.name}' contexts must be the first parameter: '${i}'.`))}t.context=x;continue}let _;if((r.initializer!==void 0&&r.initializer!==null||r.questionToken!==void 0&&r.questionToken!==null)&&(l.optional=!0,r.initializer))try{_=r.initializer.kind===n.SyntaxKind.StringLiteral?r.initializer.text:r.initializer.kind===n.SyntaxKind.NumericLiteral?parseFloat(r.initializer.text):r.initializer.kind===n.SyntaxKind.TrueKeyword||r.initializer.kind===n.SyntaxKind.FalseKeyword?r.initializer.kind===n.SyntaxKind.TrueKeyword:r.initializer.kind===n.SyntaxKind.NullKeyword?null:r.initializer.kind===n.SyntaxKind.ObjectLiteralExpression||r.initializer.kind===n.SyntaxKind.ArrayLiteralExpression?r.initializer.getText():r.initializer.getText?.()}catch(s){console.warn(`Couldn't extract default value for parameter '${l.name}'`,s)}r.dotDotDotToken&&(l.rest=!0),t.parameters.push(l);const v={description:""};d.parameters[l.name]=v;const y=P.getSymbolAtLocation(r.name).getDocumentationComment(P);y&&y.length>0&&y[0].text&&(v.description=y[0].text),_!==void 0&&(v.defaultValue=_),C.set(l.name,l)}if(e.jsDoc&&e.jsDoc.length>0){const c=e.jsDoc,r=c.length;for(let l=0;l<r;l++){const x=c[l]?.tags;if(!x)continue;const _=x.length;for(let v=0;v<_;v++){const y=x[v];let s=y?.tagName?.text;if(!s)continue;s=s.toLowerCase();let i=y.comment;const Y=s==="hidden";if((typeof i=="string"||Y)&&(typeof i=="string"&&(i=i.replace(/[\r\n]+/g,"\\n").trim()),Y||!i||(i=i.split(/\\n/)[0],i&&i.length!==0))){if(i&&typeof i=="string"){const u=/\{@link(code|plain)?\s+([^}|]+)(?:\s*\|\s*([^}]+))?\}/g;let K,N=i,A=[];for(;(K=u.exec(i))!==null;){const[V,q,oe,Z]=K,le=[oe.trim()];Z&&le.push(Z.trim())}i=N,A.length>0&&s==="see"&&(d.links||(d.links=[]),d.links.push(...A))}if(s==="name"){const u=i;u!==f&&(d.name=u)}else if(s!=="description"){if(s==="summary"){const u=i;u&&(d.summary=u)}else if(s==="param"){const u=y.name?.text,K=C.get(u);if(!K){D.push(new Error(`Parameter '${u}' not found in function '${f}'.`));continue}if(y.typeExpression&&y.typeExpression.type)try{const N=y.typeExpression.type;if(N.kind===n.SyntaxKind.UnionType){const A=[];K.enums=A,N.types.forEach(V=>{if(V.kind===n.SyntaxKind.LiteralType){const q=V.literal.text;q&&A.push(q)}})}}catch(N){console.warn("Error parsing JSDoc type expression:",N)}}else if(s==="returns"||s==="return")t.returnType.description=i;else if(s==="category")d.category=i;else if(s==="hidden"){let u=!0;const K=i?.toLowerCase();K==="false"?u=!1:K!=="true"&&(u=i),u!==!1&&(d.hidden=u??!0)}}}}}}Object.keys(t.returnType).length===0&&delete t.returnType,p.push([t,d])}catch(o){k(e,new Error(`'${f}': ${o.message}`))}}}),D.length>0)throw console.warn(D),new Error("There were compilation errors.",{cause:D});if(p.length===0)throw new Error("No exported functions.");const ae=`${se.uuidV4()}-script`;try{S||D.length!==0||(z=await ue(0,z,a))}catch{console.warn("Error bundling script")}const Q={functions:p,commitId:ae,source:w,name:"Script",language:"typescript",compiled:z};return h&&(Q.autoRun=h),Q}export{Ee as compileModule};
